// Generated by CoffeeScript 2.7.0
//###########################################################
//region modules
var acceptSecretsFrom, addNodeId, createSignature, decrypt, deleteSecret, deleteSharedSecret, encrypt, getSecret, getSecretSpace, prepareNewKeys, removeNodeId, setSecret, shareSecretTo, stopAcceptSecretsFrom;

import * as secUtl from "secret-manager-crypto-utils";

import * as tbut from "thingy-byte-utils";

import * as sci from "./secretmanagementinterface.js";

import * as timestampCreator from "./validatabletimestampmodule.js";

//endregion

  //###########################################################
export var Client = class Client {
  constructor(secretKeyHex1, publicKeyHex, serverURL1, closureDate1, authCode) {
    this.secretKeyHex = secretKeyHex1;
    this.publicKeyHex = publicKeyHex;
    this.serverURL = serverURL1;
    this.closureDate = closureDate1;
    if ((this.secretKeyHex != null) && (this.secretKeyHex != null)) {
      this.secretKeyBytes = tbut.hexToBytes(this.secretKeyHex);
      this.publicKeyBytes = tbut.hexToBytes(this.publicKeyHex);
      this.keysReady = true;
    } else {
      this.keysReady = prepareNewKeys(this);
    }
    if (authCode != null) {
      this.ready = addNodeId(this, authCode);
    } else if (this.keysReady === true) {
      this.ready = true;
    } else {
      throw new Error("Unexpected Error: We neither have an authCode nor keys.");
    }
  }

  updateServerURL(serverURL, authCode) {
    this.serverURL = serverURL;
    return this.ready = addNodeId(this, authCode);
  }

  async eraseFromServer() {
    await this.ready;
    this.ready = removeNodeId(this);
    return (await this.ready);
  }

  async getSecretSpace() {
    var secret;
    await this.ready;
    secret = (await getSecretSpace(this));
    return (await decrypt(secret, this.secretKeyHex));
  }

  async getSecret(secretId) {
    var secret;
    await this.ready;
    secret = (await getSecret(secretId, this));
    return (await decrypt(secret, this.secretKeyHex));
  }

  async getSecretFrom(secretId, fromId) {
    var secret;
    await this.ready;
    secretId = fromId + "." + secretId;
    secret = (await getSecret(secretId, this));
    return (await decrypt(secret, this.secretKeyHex));
  }

  async setSecret(secretId, secret) {
    await this.ready;
    secret = (await encrypt(secret, this.publicKeyHex));
    return (await setSecret(secretId, secret, this));
  }

  async deleteSecret(secretId) {
    await this.ready;
    return (await deleteSecret(secretId, this));
  }

  async acceptSecretsFrom(fromId) {
    await this.ready;
    return (await acceptSecretsFrom(fromId, this));
  }

  async stopAcceptSecretsFrom(fromId) {
    await this.ready;
    return (await stopAcceptSecretsFrom(fromId, this));
  }

  async shareSecretTo(shareToId, secretId, secret) {
    await this.ready;
    secret = (await encrypt(secret, shareToId));
    return (await shareSecretTo(shareToId, secretId, secret, this));
  }

  async deleteSharedSecret(sharedToId, secretId) {
    await this.ready;
    return (await deleteSharedSecret(sharedToId, secretId, this));
  }

};

//###########################################################
//region internalFunctions

//###########################################################
//region cryptoHelpers
decrypt = async function(content, secretKey) {
  var err;
  content = (await secUtl.asymmetricDecrypt(content, secretKey));
  content = secUtl.removeSalt(content);
  try {
    content = JSON.parse(content);
  } catch (error) {
    err = error;
    return content; // was no stringified Object
  }
  if ((content.encryptedContent != null) || (content.encryptedContentHex != null)) {
    content = (await secUtl.asymmetricDecrypt(content, secretKey));
    content = secUtl.removeSalt(content);
    try {
      content = JSON.parse(content);
    } catch (error) {
      err = error;
      return content; // was no stringified Object
    }
  }
  return content;
};

//###########################################################
encrypt = async function(content, publicKey) {
  var salt;
  if (typeof content === "object") {
    content = JSON.stringify(content);
  }
  salt = secUtl.createRandomLengthSalt();
  content = salt + content;
  content = (await secUtl.asymmetricEncrypt(content, publicKey));
  return JSON.stringify(content);
};

//###########################################################
createSignature = async function(payload, route, secretKeyHex) {
  var content;
  content = route + JSON.stringify(payload);
  return (await secUtl.createSignature(content, secretKeyHex));
};

//###########################################################
prepareNewKeys = async function(client) {
  var kp;
  if (client.secretKeyHex == null) {
    kp = (await secUtl.createKeyPairHex());
    client.secretKeyHex = kp.secretKeyHex;
    client.publicKeyHex = kp.publicKeyHex;
  } else {
    client.publicKeyHex = (await secUtl.createPublicKeyHex(secretKeyHex));
  }
  client.secretKeyBytes = tbut.hexToBytes(client.secretKeyHex);
  client.publicKeyBytes = tbut.hexToBytes(client.publicKeyHex);
  return true;
};

//endregion

//###########################################################
//region effectiveSCI
addNodeId = async function(client, authCode) {
  var closureDate, payload, publicKey, response, route, secretKey, server, signature, timestamp;
  await client.keysReady;
  console.log("addNodeId called!");
  server = client.serverURL;
  secretKey = client.secretKeyHex;
  publicKey = client.publicKeyHex;
  timestamp = timestampCreator.create();
  closureDate = client.closureDate;
  payload = {authCode, publicKey, closureDate, timestamp};
  route = "/addNodeId";
  signature = (await createSignature(payload, route, secretKey));
  console.log("created Signature!");
  response = (await sci.addNodeId(server, authCode, publicKey, closureDate, timestamp, signature));
  if (response.ok) {
    return true;
  } else {
    throw new Error("addNodeId failed: " + response.error);
  }
};

removeNodeId = async function(client) {
  var payload, publicKey, response, route, secretKey, server, signature, timestamp;
  server = client.serverURL;
  publicKey = client.publicKeyHex;
  secretKey = client.secretKeyHex;
  timestamp = timestampCreator.create();
  payload = {publicKey, timestamp};
  route = "/removeNodeId";
  signature = (await createSignature(payload, route, secretKey));
  response = (await sci.removeNodeId(server, publicKey, timestamp, signature));
  if (response.ok) {
    return true;
  } else {
    throw new Error("removeNodeId failed: " + response.error);
  }
};

//###########################################################
getSecretSpace = async function(client) {
  var payload, publicKey, route, secretKey, server, signature, timestamp;
  server = client.serverURL;
  publicKey = client.publicKeyHex;
  secretKey = client.secretKeyHex;
  timestamp = timestampCreator.create();
  payload = {publicKey, timestamp};
  route = "/getSecretSpace";
  signature = (await createSignature(payload, route, secretKey));
  return (await sci.getSecretSpace(server, publicKey, timestamp, signature));
};

getSecret = async function(secretId, client) {
  var payload, publicKey, route, secretKey, server, signature, timestamp;
  server = client.serverURL;
  publicKey = client.publicKeyHex;
  secretKey = client.secretKeyHex;
  timestamp = timestampCreator.create();
  payload = {publicKey, secretId, timestamp};
  route = "/getSecret";
  signature = (await createSignature(payload, route, secretKey));
  return (await sci.getSecret(server, publicKey, secretId, timestamp, signature));
};

//###########################################################
setSecret = async function(secretId, secret, client) {
  var payload, publicKey, route, secretKey, server, signature, timestamp;
  server = client.serverURL;
  publicKey = client.publicKeyHex;
  secretKey = client.secretKeyHex;
  timestamp = timestampCreator.create();
  payload = {publicKey, secretId, secret, timestamp};
  route = "/setSecret";
  signature = (await createSignature(payload, route, secretKey));
  return (await sci.setSecret(server, publicKey, secretId, secret, timestamp, signature));
};

deleteSecret = async function(secretId, client) {
  var payload, publicKey, route, secretKey, server, signature, timestamp;
  server = client.serverURL;
  publicKey = client.publicKeyHex;
  secretKey = client.secretKeyHex;
  timestamp = timestampCreator.create();
  payload = {publicKey, secretId, timestamp};
  route = "/deleteSecret";
  signature = (await createSignature(payload, route, secretKey));
  return (await sci.deleteSecret(server, publicKey, secretId, timestamp, signature));
};

//###########################################################
acceptSecretsFrom = async function(fromId, client) {
  var payload, publicKey, route, secretKey, server, signature, timestamp;
  server = client.serverURL;
  publicKey = client.publicKeyHex;
  secretKey = client.secretKeyHex;
  timestamp = timestampCreator.create();
  payload = {publicKey, fromId, timestamp};
  route = "/startAcceptingSecretsFrom";
  signature = (await createSignature(payload, route, secretKey));
  return (await sci.startAcceptingSecretsFrom(server, publicKey, fromId, timestamp, signature));
};

stopAcceptSecretsFrom = async function(fromId, client) {
  var payload, publicKey, route, secretKey, server, signature, timestamp;
  server = client.serverURL;
  publicKey = client.publicKeyHex;
  secretKey = client.secretKeyHex;
  timestamp = timestampCreator.create();
  payload = {publicKey, fromId, timestamp};
  route = "/stopAcceptingSecretsFrom";
  signature = (await createSignature(payload, route, secretKey));
  return (await sci.stopAcceptingSecretsFrom(server, publicKey, fromId, timestamp, signature));
};

//###########################################################
shareSecretTo = async function(shareToId, secretId, secret, client) {
  var payload, publicKey, route, secretKey, server, signature, timestamp;
  server = client.serverURL;
  publicKey = client.publicKeyHex;
  secretKey = client.secretKeyHex;
  timestamp = timestampCreator.create();
  payload = {publicKey, shareToId, secretId, secret, timestamp};
  route = "/shareSecretTo";
  signature = (await createSignature(payload, route, secretKey));
  return (await sci.shareSecretTo(server, publicKey, shareToId, secretId, secret, timestamp, signature));
};

deleteSharedSecret = async function(sharedToId, secretId, client) {
  var payload, publicKey, route, secretKey, server, signature, timestamp;
  server = client.serverURL;
  publicKey = client.publicKeyHex;
  secretKey = client.secretKeyHex;
  timestamp = timestampCreator.create();
  payload = {publicKey, sharedToId, secretId, timestamp};
  route = "/deleteSharedSecret";
  signature = (await createSignature(payload, route, secretKey));
  return (await sci.deleteSharedSecret(server, publicKey, sharedToId, secretId, timestamp, signature));
};

//endregion

//endregion
