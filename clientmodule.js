// Generated by CoffeeScript 2.5.1
(function() {
  var Client, acceptSecretsFrom, addNodeId, clientmodule, createSignature, decrypt, deleteSecret, deleteSharedSecret, encrypt, getSecret, getSecretSpace, network, newSecretBytes, noble, secUtl, secretmanagerinterface, setSecret, shareSecretTo, stopAcceptSecretsFrom, tbut;

  clientmodule = {};

  //###########################################################
  //region modules
  noble = require("noble-ed25519");

  tbut = require("./thingybyteutils");

  secUtl = require("./secretmanagercryptoutils");

  secretmanagerinterface = require("./secretmanagerinterface");

  network = require("./network");

  Object.assign(network, secretmanagerinterface);

  //endregion

    //###########################################################
  Client = class Client {
    constructor(secretKeyHex1, publicKeyHex1, serverURL1) {
      this.secretKeyHex = secretKeyHex1;
      this.publicKeyHex = publicKeyHex1;
      this.serverURL = serverURL1;
      this.ready = addNodeId(this);
    }

    updateServerURL(serverURL) {
      this.serverURL = serverURL;
      return this.ready = addNodeId(this);
    }

    async getSecretSpace() {
      var secret;
      await this.ready;
      secret = (await getSecretSpace(this));
      return (await decrypt(secret, this.secretKeyHex));
    }

    async getSecret(secretId) {
      var secret;
      await this.ready;
      secret = (await getSecret(secretId, this));
      return (await decrypt(secret, this.secretKeyHex));
    }

    async getSecretFrom(secretId, fromId) {
      var secret;
      await this.ready;
      secretId = fromId + "." + secretId;
      secret = (await getSecret(secretId, this));
      return (await decrypt(secret, this.secretKeyHex));
    }

    async setSecret(secretId, secret) {
      await this.ready;
      secret = (await encrypt(secret, this.publicKeyHex));
      return (await setSecret(secretId, secret, this));
    }

    async deleteSecret(secretId) {
      await this.ready;
      return (await deleteSecret(secretId, this));
    }

    async acceptSecretsFrom(fromId) {
      await this.ready;
      return (await acceptSecretsFrom(fromId, this));
    }

    async stopAcceptSecretsFrom(fromId) {
      await this.ready;
      return (await stopAcceptSecretsFrom(fromId, this));
    }

    async shareSecretTo(shareToId, secretId, secret) {
      await this.ready;
      secret = (await encrypt(secret, shareToId));
      return (await shareSecretTo(shareToId, secretId, secret, this));
    }

    async deleteSharedSecret(sharedToId, secretId) {
      await this.ready;
      return (await deleteSharedSecret(sharedToId, secretId, this));
    }

  };

  //###########################################################
  //region internalFunctions

  //###########################################################
  //region cryptoHelpers
  newSecretBytes = noble.utils.randomPrivateKey;

  //###########################################################
  decrypt = async function(content, secretKey) {
    var err;
    content = (await secUtl.asymetricDecrypt(content, secretKey));
    content = secUtl.removeSalt(content);
    try {
      content = JSON.parse(content);
    } catch (error) {
      err = error;
      return content; // was no stringified Object
    }
    if (content.encryptedContent != null) {
      content = (await secUtl.asymetricDecrypt(content, secretKey));
      content = secUtl.removeSalt(content);
      try {
        content = JSON.parse(content);
      } catch (error) {
        err = error;
        return content; // was no stringified Object
      }
    }
    return content;
  };

  //###########################################################
  encrypt = async function(content, publicKey) {
    var salt;
    if (typeof content === "object") {
      content = JSON.stringify(content);
    }
    salt = secUtl.createRandomLengthSalt();
    content = salt + content;
    content = (await secUtl.asymetricEncrypt(content, publicKey));
    return JSON.stringify(content);
  };

  //###########################################################
  createSignature = async function(payload, route, secretKeyHex) {
    var content;
    content = route + JSON.stringify(payload);
    return (await secUtl.createSignature(content, secretKeyHex));
  };

  //endregion

  //###########################################################
  //region effectiveNetworkCommunication
  addNodeId = async function(client) {
    var payload, publicKey, route, secretKey, server, signature, timestamp;
    server = client.serverURL;
    publicKey = client.publicKeyHex;
    secretKey = client.secretKeyHex;
    timestamp = "";
    payload = {publicKey, timestamp};
    route = "/addNodeId";
    signature = (await createSignature(payload, route, secretKey));
    return (await network.addNodeId(server, publicKey, timestamp, signature));
  };

  //###########################################################
  getSecretSpace = async function(client) {
    var payload, publicKey, route, secretKey, server, signature, timestamp;
    server = client.serverURL;
    publicKey = client.publicKeyHex;
    secretKey = client.secretKeyHex;
    timestamp = "";
    payload = {publicKey, timestamp};
    route = "/getSecretSpace";
    signature = (await createSignature(payload, route, secretKey));
    return (await network.getSecretSpace(server, publicKey, timestamp, signature));
  };

  getSecret = async function(secretId, client) {
    var payload, publicKey, route, secretKey, server, signature, timestamp;
    server = client.serverURL;
    publicKey = client.publicKeyHex;
    secretKey = client.secretKeyHex;
    timestamp = "";
    payload = {publicKey, secretId, timestamp};
    route = "/getSecret";
    signature = (await createSignature(payload, route, secretKey));
    return (await network.getSecret(server, publicKey, secretId, timestamp, signature));
  };

  //###########################################################
  setSecret = async function(secretId, secret, client) {
    var payload, publicKey, route, secretKey, server, signature, timestamp;
    server = client.serverURL;
    publicKey = client.publicKeyHex;
    secretKey = client.secretKeyHex;
    timestamp = "";
    payload = {publicKey, secretId, secret, timestamp};
    route = "/setSecret";
    signature = (await createSignature(payload, route, secretKey));
    return (await network.setSecret(server, publicKey, secretId, secret, timestamp, signature));
  };

  deleteSecret = async function(secretId, client) {
    var payload, publicKey, route, secretKey, server, signature, timestamp;
    server = client.serverURL;
    publicKey = client.publicKeyHex;
    secretKey = client.secretKeyHex;
    timestamp = "";
    payload = {publicKey, secretId, timestamp};
    route = "/deleteSecret";
    signature = (await createSignature(payload, route, secretKey));
    return (await network.deleteSecret(server, publicKey, secretId, timestamp, signature));
  };

  //###########################################################
  acceptSecretsFrom = async function(fromId, client) {
    var payload, publicKey, route, secretKey, server, signature, timestamp;
    server = client.serverURL;
    publicKey = client.publicKeyHex;
    secretKey = client.secretKeyHex;
    timestamp = "";
    payload = {publicKey, fromId, timestamp};
    route = "/startAcceptingSecretsFrom";
    signature = (await createSignature(payload, route, secretKey));
    return (await network.startAcceptingSecretsFrom(server, publicKey, fromId, timestamp, signature));
  };

  stopAcceptSecretsFrom = async function(fromId, client) {
    var payload, publicKey, route, secretKey, server, signature, timestamp;
    server = client.serverURL;
    publicKey = client.publicKeyHex;
    secretKey = client.secretKeyHex;
    timestamp = "";
    payload = {publicKey, fromId, timestamp};
    route = "/stopAcceptingSecretsFrom";
    signature = (await createSignature(payload, route, secretKey));
    return (await network.stopAcceptingSecretsFrom(server, publicKey, fromId, timestamp, signature));
  };

  //###########################################################
  shareSecretTo = async function(shareToId, secretId, secret, client) {
    var payload, publicKey, route, secretKey, server, signature, timestamp;
    server = client.serverURL;
    publicKey = client.publicKeyHex;
    secretKey = client.secretKeyHex;
    timestamp = "";
    payload = {publicKey, shareToId, secretId, secret, timestamp};
    route = "/shareSecretTo";
    signature = (await createSignature(payload, route, secretKey));
    return (await network.shareSecretTo(server, publicKey, shareToId, secretId, secret, timestamp, signature));
  };

  deleteSharedSecret = async function(sharedToId, secretId, client) {
    var payload, publicKey, route, secretKey, server, signature, timestamp;
    server = client.serverURL;
    publicKey = client.publicKeyHex;
    secretKey = client.secretKeyHex;
    timestamp = "";
    payload = {publicKey, sharedToId, secretId, timestamp};
    route = "/deleteSharedSecret";
    signature = (await createSignature(payload, route, secretKey));
    return (await network.deleteSharedSecret(server, publicKey, sharedToId, secretId, timestamp, signature));
  };

  //endregion

  //endregion

  //###########################################################
  clientmodule.createClient = async function(secretKeyHex, publicKeyHex, serverURL) {
    if (!secretKeyHex) {
      secretKeyHex = tbut.bytesToHex(newSecretBytes());
      publicKeyHex = (await noble.getPublicKey(secretKeyHex));
    }
    if (!publicKeyHex) {
      publicKeyHex = (await noble.getPublicKey(secretKeyHex));
    }
    return new Client(secretKeyHex, publicKeyHex, serverURL);
  };

  module.exports = clientmodule;

}).call(this);
